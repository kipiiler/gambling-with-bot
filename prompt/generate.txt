You are an expert poker AI developer with deep expertise in game theory, probability, and real-time decision-making, tasked with creating the ultimate bot for Husky Hold'em, a No-Limit Texas Hold'em poker bot competition. Your goal is to implement a high-performing SimplePlayer bot that maximizes **delta money** (ending chips minus starting chips) across multi-game simulations, while adhering strictly to all technical constraints and producing error-free, efficient code.

This is an iterative development process: You will receive an initial prompt to generate the bot. After each generation, we will provide evaluation results, including:
- Error logs (e.g., tracebacks from crashes, timeouts, memory violations, exceptions, or invalid actions leading to automatic folds).
- Success metrics (e.g., functional execution rate: percentage of successful runs without failures; final delta money: average net chip gains per hand/game; variance in behavior: statistical variance of action scores showing adaptability).
- Game logs (e.g., summaries of hands played, opponent actions, chip changes, and overall performance against baselines like house bots or other LLM-generated opponents).

Use these results to iterate: Fix any errors precisely (e.g., attribute access issues, invalid actions, timeouts), analyze performance gaps (e.g., if delta money is low, improve strategy for bluffing or equity calculation), and enhance the bot for better adaptability and profitability. Aim to converge on the optimal bot within n iterations by building on prior versions.

**Key Constraints and Requirements**
- **Technical Limits**: Decisions must complete in ≤30 seconds (timeout = auto-fold); memory ≤100MB; any error/exception = auto-fold. Code must be robust, with explicit error handling and efficient algorithms (e.g., avoid infinite loops or heavy computations).
- **Game Setup**: 6-handed tables; players start with 1,000 chips; simulations run >10 games per evaluation with rotating/increasing blinds (e.g., small/big blinds start at 5/10, increase after rounds); persistent chips across games; no rebuys—if chips reach 0, bot folds and loses on blinds.
- **Poker Rules**: Standard No-Limit Texas Hold'em. 4 rounds: PREFLOP (2 hole cards, blinds), FLOP (3 community cards), TURN (1 card), RIVER (1 card). Actions: FOLD, CHECK (only if current_bet == 0), CALL (matches current_bet - your bet), RAISE (amount must make total bet > current_bet and ≥ min_raise), ALL_IN (commits all chips). Showdown: Best 5-card hand wins (rankings: Royal Flush > Straight Flush > Quads > Full House > Flush > Straight > Trips > Two Pair > Pair > High Card). Handle multi-way pots, side pots (for all-ins), positions (derive from all_players list and current_player), incomplete info, bluffing.
- **Evaluation Metrics** (from Husky Hold'em benchmark): Maximize functional execution rate (100% success without failures), final delta money (positive and high), and variance in behavior (moderate to high for adaptability: score actions as -1 for defensive (FOLD/CHECK/CALL), +1 for aggressive (RAISE/ALL_IN), compute variance across rounds).
- **Bot Implementation Rules**:
  - Subclass Bot as SimplePlayer exactly; do not rename the class or change method signatures.
  - Store state in instance variables (e.g., self.hole_cards from on_start, self.history for opponent modeling across rounds/games).
  - In get_action, always return a valid Tuple[PokerAction, int] (amount=0 for non-RAISE/ALL_IN; for RAISE, ensure amount ≥ min_raise and ≤ max_raise; validate conditions like CHECK only if current_bet == 0).
  - Invalid actions auto-fold and penalize delta money—add checks for all edge cases (e.g., low stack, all-in scenarios, side pots).
  - Use advanced strategies: GTO-inspired (balance ranges), hand equity (e.g., simple Monte Carlo simulations if time allows), opponent modeling (track player_actions, player_bets, player_money in history), position-aware decisions, bluffing based on board texture/community_cards, adapt to blind increases and stack sizes.
  - Pure Python only; list dependencies in requirements.txt if needed (e.g., numpy for math); keep efficient to meet limits.
- **State Management**: Hole cards are provided only in on_start as player_hands (your bot's cards, e.g., ['Ah', 'Ks']). Store them in self.hole_cards. RoundStateClient provides community_cards, pot, current_player (list of active player IDs, your position is index of self.id), current_bet, min_raise, max_raise, player_bets (dict of bets by player ID), player_actions (dict of actions by player ID), side_pots (list of dicts with 'amount' and 'eligible_players')—use these for decisions. Track history across methods for multi-game persistence.

**SimplePlayer Template** (implement all methods; add helpers as needed):
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        # Initialize instance variables here (e.g., self.hole_cards = [], self.history = {})

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        # Store starting state, e.g., self.hole_cards = player_hands; initialize history

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # Prepare for new round, e.g., reset round-specific state

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        # Compute and return valid action based on state; validate all conditions

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        # Update history from round outcome

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # Final updates or logging
```

**Small Example Bot** (basic implementation that always checks if possible or folds; use this as a starting point for inspiration, but expand to advanced strategies for better performance):
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        self.hole_cards = []

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        self.hole_cards = player_hands

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        pass

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        if round_state.current_bet == 0:
            return PokerAction.CHECK, 0
        else:
            return PokerAction.FOLD, 0

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        pass

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        pass
```

**Few-Shot Strategy Examples**:
- PREFLOP, hole_cards=['Ah','As'], position=late (self.id near end of current_player), prior raise (player_actions shows RAISE): If equity high (>80% vs. range), RAISE to 3x prior bet if stack >= amount, else CALL or ALL_IN.
- RIVER, top pair (e.g., hole_cards + community_cards form pair > board), opponent aggressive (high player_bets): If pot odds > equity, CALL; else FOLD. Bluff RAISE if board scary and actions weak.
- Low stack ( 'RoundStateClient':
        return cls(**{k: message.get(k) for k in cls.__annotations__}, side_pots=message.get('side_pots', []))
```
- **PokerAction**:
```python
from enum import Enum

class PokerAction(Enum):
    FOLD = 1
    CHECK = 2
    CALL = 3
    RAISE = 4
    ALL_IN = 5
```
- **Bot** (abstract, do not modify):
```python
from abc import ABC, abstractmethod
from typing import List, Tuple
from type.round_state import RoundStateClient
from type.poker_action import PokerAction

class Bot(ABC):
    def __init__(self) -> None:
        self.id = None

    def set_id(self, player_id: int) -> None:
        self.id = player_id

    @abstractmethod
    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]) -> None:
        pass

    @abstractmethod
    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        pass

    @abstractmethod
    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        pass

    @abstractmethod
    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        pass

    @abstractmethod
    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict) -> None:
        pass
```

**Response Format**: Output ONLY two blocks: complete player.py (Python code block) with your implementation, and requirements.txt (text block, empty if no dependencies). No other text. If this is an iteration, reference provided logs to fix/improve.